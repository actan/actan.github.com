---
layout: post
title: 一个假空格引发的惨案
category: tech
---

面试时不是有一个常问的问题是“你解决过什么比较难的bug”吗，或者是“有没有什么让你印象深刻的bug”。说实话这么多年了自己感觉是解决了一些棘手的bug，
但是真要一段时间之后想再提起来并给别人讲明白，还真不是那么容易。

原因嘛

1. 坦白说很多解决的bug最后证明不是多么高精尖，不太值得一提，提出来反倒会让面试官觉得小题大做

2. 时间过去太久了，解决了就解决了，不一会儿就投入到新的bug中了，老bug除非再次遇到，不然还真一下子想不起来 

第一点其实也不完全对，因为很多时候事实证明解决方法并不复杂，甚至是程序员自己犯了低级错误，不过查找错误的过程以及排查的思维路径却很重要，正确的分析思路也是非常值得一提的。 
第二点嘛，反正自己记性越来越差了，还是老实点写下来吧，权当是个总结，练习下语言组织能力。

### Postman里面是好的，但是真实应用里面却报错

今天就遇到一个非常诡异的案例：同样的接口，同样的参数，在postman里都是可以的，但是在线上环境里却死活报错。

原因应该可以初步确定是两种请求有些细微的差别，但是肉眼看瞎了也看不出什么区别，把整个请求保存成text放在diff的工具里对比也对比不出什么不同，甚至把可疑的请求参数都从线上
拷贝了一份到postman里面，依然在postman里无法重现，到底是哪里造成了这种不同呢？

没办法，只能老老实实在后台接口的代码里给每一步可疑的地方加日志，部署，再看。终于发现了：

```
Bearer eyJhbGciOiJkaXIiLCJlbmMi
```

后台收到上面的字符串后split空格后居然得到array size是1！就是说那个看似的空格其实并不是空格。

OK, 不是空格那它是什么呢？把上面有问题的这段string拷贝到postman里再试，好的，Ctrl+C还是不会搞小动作的，问题重现了。那么把这串字符的acsii代码打印出来，检查。

好了，那个“空格”是一个假空格，Ascii代码是160而不是32，它显示成空格只是找不到对应的字符而已。(唉，那个假空格是同事传的呀)

![image](https://nsaufw.dm.files.1drv.com/y4m8uGa1Tt-T6mcJrMdUlNbQ4M5uk6Xsis1FhRWI1hLDOsZ6jK8GTPMpLgSIra0wD1_Z5jKKDGwqMR6JdfeGHq7mDrLMyC-Nq6pcelbIiPDGvWjUwphZtYC76juOaqeFdwQB1adk5DfTaNQ05d0CyjNGw_lRcEzSwKc4V9hJSwoEZBAf7oju0-Q_u6zFZ7rfHKw?width=129&height=376&cropmode=none)


### 结论

1. 直接引用定义好的常量更好，手动输入总会难免出错

2. 平时可以写一些debug级别的日志在代码里面，查错的时候直接打开debug级别就行了，省得急忙临时再添加一遍
